######created by [osman-boy](https://github.com/osman-boy)

Принцип замещения Лискова
Этот принцип предполагает, что «родительские классы должны быть легко заменены их дочерними классами, не взрывая приложение». Давайте возьмем следующий пример, чтобы понять это.
Мы должны иметь возможность использовать подклассы вместо родительских классов, класс которых они расширили, без необходимости вносить какие-либо изменения в наш код. Проще говоря, дочерний класс должен быть заменяемым родительским классом.Поскольку
дочерние классы расширяются от родительских классов, они наследуют свое поведение
Если дочерние классы не могут выполнять поведение, принадлежащее родительским классам, вероятно, 
мы не будем писать код в методе, который выполняет поведение, или мы будем выдавать ошибку,
когда объекты захотят его использовать. Но эти действия вызывают загрязнение кода и ненужные толпы кода.

<img height="300" src="lsp.png"/>


/**
* Created by osmanboy on 2/5/2022
* LSP(Liskov Substitution Principle) - Принцип подстановки Барбары Лисков.
* - Принцип гласит что мы можем заменить родительским класс дочерним классом без изменения работы программы.
* Подклассы должны дополнять, а не замещать поведение базового класса.
* Стремитесь создавать подклассы таким образом, чтобы их объекты можно было бы подставлять вместо объектов базового
* класса, не ломая при этом функциональности клиентского кода.
  */
  open class Document(val data: String , val fileName: String) {
  open fun open() = println("I'm opening the $data")
  open fun save() = println("I'm saving the $data as $fileName")
  }

/**
* Умеет только читать документы, по этому метод [save] ему не нужен.
  */
  class ReadOnlyDocuments(data: String , fileName: String) : Document(data , fileName) {
  override fun save() = throw Exception()

}

class Project(val documents: List<Document>) {
fun openAll() {
for (doc in documents) {
doc.open()
}
}

    /**
     * Метод сохранения в подклассе [ReadOnlyDocuments] выбросит исключение, если кто-то попытается вызвать
     * его метод сохранения. Базовый метод не имеет такого ограничения.
     * Из-за этого клиентский код вынужден проверять тип доку-мента при сохранении всех документов.
     * При этом нарушается ещё и принцип открытости/закрыт-сти, так как клиентский код начинает зависеть от
     * конкретного класса, который нельзя заменить на другой, не внося изменений в клиентский код.
     */
    fun saveAll() {
        for (doc in documents) {
            if (doc !is ReadOnlyDocuments) {
                doc.save()
            }
        }
    }
}
/**
* Проблему можно решить добавив интерфейс.
  */